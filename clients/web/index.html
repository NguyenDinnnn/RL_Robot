<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>·ª®NG D·ª§NG H·ªåC TƒÇNG C∆Ø·ªúNG TRONG VI·ªÜC T·ªêI ∆ØU H√ìA ƒê∆Ø·ªúNG ƒêI C·ª¶A ROBOT</title>
<link rel="stylesheet" href="style.css">

<!-- CSS nh·ªè ƒë·ªÉ s·∫Øp x·∫øp 2 h√†ng theo y√™u c·∫ßu (kh√¥ng s·ª≠a logic JS) -->
<style>
  /* Layout: 2 h√†ng - m·ªói h√†ng 2 card ngang */
  .main-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    padding: 18px;
  }
  .row {
    display: flex;
    gap: 20px;
    align-items: flex-start;
  }
  .row .card {
    flex: 1;
    min-width: 0;
  }
  /* Gi·ªØ t∆∞∆°ng th√≠ch khi style.css c√≥ quy t·∫Øc kh√°c */
</style>
</head>
<body>
<div class="main-container">

  <!-- H√ÄNG 1: M√¥i tr∆∞·ªùng (tr√°i) + ƒêi·ªÅu khi·ªÉn (ph·∫£i) -->
  <div class="row">
    <div class="card simulation-card">
      <div class="card-header">
        <span class="card-icon">ü§ñ</span>
        <span class="card-title">M√¥i Tr∆∞·ªùng M√¥ Ph·ªèng</span>
        <span style="margin-left: auto; background: rgba(255,255,255,0.2); padding: 5px 10px; border-radius: 10px; font-size: 12px;">S·∫µn s√†ng</span>
      </div>
      
      <div class="grid-container">
        <div class="grid" id="grid"></div>
        
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color robot">ü§ñ</div>
            <span>Robot</span>
          </div>
          <div class="legend-item">
            <div class="legend-color goal"></div>
            <span>M·ª•c ti√™u</span>
          </div>
          <div class="legend-item">
            <div class="legend-color obstacle"></div>
            <span>V·∫≠t c·∫£n</span>
          </div>
          <div class="legend-item">
            <div class="legend-color waypoint"></div>
            <span>ƒêi·ªÉm trung gian</span>
          </div>
        </div>
        
        <div id="msg" class="status-message">M√¥i tr∆∞·ªùng ƒë√£ ƒë∆∞·ª£c reset</div>
      </div>
    </div>

    <div class="card combined-control-card">
      <div class="combined-content">
        <div class="control-section">
          <div class="section-header">
            <span class="card-icon">üéÆ</span>
            <span class="card-title">ƒêi·ªÅu Khi·ªÉn Robot</span>
          </div>
          
          <div class="button-group">
            <button class="btn btn-start" onclick="startAutoMove('random')">‚ñ∂ Auto Move (Random)</button>
            <button class="btn btn-start" onclick="startAutoMove('greedy')">‚ñ∂ Auto Move (Greedy)</button>
            <button class="btn btn-stop" onclick="stopAll()">üõë Stop</button>
          </div>
                    
          <div class="button-group">
            <button class="btn btn-reset" onclick="resetGrid()">üîÑ Reset</button>
            <button class="btn btn-reset" onclick="resetAllGrid()">üåç Reset All</button>
            <button class="btn btn-debug" onclick="toggleDebug()">üîß Debug</button>
          </div>
          
          <div id="manualControls" class="manual-controls" style="display:none;">
            <h4 style="text-align:center; margin-bottom:10px;">ƒêi·ªÅu khi·ªÉn th·ªß c√¥ng</h4>
            <div class="direction-buttons">
              <button class="btn btn-debug" onclick="manualMove('up')">‚Üë</button>
              <button class="btn btn-debug" onclick="manualMove('right')">‚Üí</button>
              <button class="btn btn-debug" onclick="manualMove('down')">‚Üì</button>
              <button class="btn btn-debug" onclick="manualMove('left')">‚Üê</button>
            </div>
          </div>
        </div>

        <div class="algorithm-section">
          <div class="section-header">
            <span class="card-icon">üß†</span>
            <span class="card-title">Thu·∫≠t To√°n H·ªçc TƒÉng C∆∞·ªùng</span>
          </div>
          
          <div class="algorithm-buttons">
            <button class="btn-algorithm" onclick="runAlgorithm('MC')">Monte Carlo</button>
            <button class="btn-algorithm" onclick="runAlgorithm('Q-learning')">Q-Learning</button>
            <button class="btn-algorithm" onclick="runAlgorithm('SARSA')">SARSA</button>
            <button class="btn-algorithm" onclick="runAlgorithm('A2C')">A2C</button>
            <button class="btn-algorithm" onclick="runAStar()">A*</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- H√ÄNG 2: Reward (tr√°i) + Th·ªëng k√™ hi·ªáu su·∫•t (ph·∫£i) -->
  <div class="row">
    <div class="card stats-card">
      <div class="card-header">
        <span class="card-icon">üìà</span>
        <span class="card-title">Bi·ªÉu ƒë·ªì mi·ªÅn th·ªÉ hi·ªán h√†m ph·∫ßn th∆∞·ªüng theo b∆∞·ªõc ƒëi</span>
      </div>
      <canvas id="rewardChart" width="300" height="240"></canvas>
    </div>

    <div class="card stats-card">
      <div class="card-header">
        <span class="card-icon">üìä</span>
        <span class="card-title">Th·ªëng K√™ Hi·ªáu Su·∫•t</span>
      </div>
      
      <div class="stats-grid">
        <div class="stat-item">
          <div class="stat-label">THU·∫¨T TO√ÅN</div>
          <div class="stat-value" id="current-algorithm">-</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">REWARD</div>
          <div class="stat-value" id="current-reward">-</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">STEP</div>
          <div class="stat-value" id="current-steps">-</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">WAYPOINTS</div>
          <div class="stat-value" id="current-waypoints">-</div>
        </div>
        <div class="stat-item">
          <div class="stat-label">TH·ªúI GIAN</div>
          <div class="stat-value" id="current-time">-</div>
        </div>
      </div>
      
      <div id="algoResult" class="algo-result" style="display:none;"></div>

      <canvas id="trajectory" width="300" height="240" style="border:1px solid #ccc; margin-top:10px;"></canvas>
    </div>
  </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// ---------------- Bi·∫øn to√†n c·ª•c ----------------
let gridSizeX = 10, gridSizeY = 8;
let robotPos = [0, 0], goal = [9, 7], obstacles = [], waypoints = [], visitedWaypoints = [];
let autoMoving = false, algoMoving = false, intervalId = null, debugMode = false, currentAlgo = null;
let startTime = null, endTime = null, trajectoryPoints = [];
let allAlgoData = {};
let currentAlgoData = { rewards: [], totalReward: 0 }; // Bi·∫øn m·ªõi ƒë·ªÉ l∆∞u tr·ªØ d·ªØ li·ªáu c·ªßa thu·∫≠t to√°n ƒëang ch·∫°y

// ---------------- Chart ----------------
const ctx = document.getElementById('rewardChart').getContext('2d');
const rewardChart = new Chart(ctx, {
    type: 'line',
    data: { labels: [], datasets: [] },
    options: {
        responsive:true,
        plugins:{ title:{ display:true, text:'Reward theo Step' } },
        scales:{ x:{ title:{ display:true, text:'Step' } }, y:{ title:{ display:true, text:'Reward' } } }
    }
});

function randomColor(alpha=1){
    const r=Math.floor(Math.random()*255), g=Math.floor(Math.random()*255), b=Math.floor(Math.random()*255);
    return `rgba(${r},${g},${b},${alpha})`;
}

function updateChart() {
    rewardChart.data.datasets = [];
    let maxSteps = 0;
    
    for (const algo in allAlgoData) {
        if (allAlgoData[algo].rewards.length > maxSteps) {
            maxSteps = allAlgoData[algo].rewards.length;
        }
    }
    rewardChart.data.labels = Array.from({length: maxSteps}, (_, i) => i + 1);

    for (const algo in allAlgoData) {
        rewardChart.data.datasets.push({
            label: algo,
            data: allAlgoData[algo].rewards,
            borderColor: allAlgoData[algo].color,
            backgroundColor: allAlgoData[algo].color.replace('rgb', 'rgba').replace(')', ', 0.2)'),
            fill: false,
            tension: 0.3,
            pointRadius: 0
        });
    }
    rewardChart.update();
}

// ---------------- Grid & Robot ----------------
function drawGridOnce(){
    let grid=document.getElementById("grid");
    grid.style.gridTemplateColumns=`repeat(${gridSizeX},35px)`;
    grid.innerHTML="";
    for(let y=0;y<gridSizeY;y++){
        for(let x=0;x<gridSizeX;x++){
            let cell=document.createElement("div");
            cell.classList.add("cell");
            cell.dataset.x=x; cell.dataset.y=y;
            if(obstacles.some(o=>o[0]===x&&o[1]===y)) cell.classList.add("obstacle");
            if(waypoints.some(w=>w[0]===x&&w[1]===y && !visitedWaypoints.some(vw=>vw[0]===w[0] && vw[1]===w[1]))) cell.classList.add("waypoint");
            if(x===goal[0]&&y===goal[1]) cell.classList.add("goal");
            if(x===robotPos[0]&&y===robotPos[1]) { cell.classList.add("robot"); cell.innerHTML="ü§ñ"; }
            grid.appendChild(cell);
        }
    }
}

function updateRobot(prevPos, newPos){
    let grid=document.getElementById("grid");
    let oldCell=grid.querySelector(`.cell[data-x='${prevPos[0]}'][data-y='${prevPos[1]}']`);
    if(oldCell){ oldCell.classList.remove("robot"); oldCell.innerHTML=""; }
    let newCell=grid.querySelector(`.cell[data-x='${newPos[0]}'][data-y='${newPos[1]}']`);
    if(newCell){ newCell.classList.add("robot"); newCell.innerHTML="ü§ñ"; }
    trajectoryPoints.push([...newPos]);

    if(newPos[0]===goal[0] && newPos[1]===goal[1]){
        endTime = performance.now();
        let elapsed = ((endTime - startTime)/1000).toFixed(2);
        document.getElementById("current-time").innerText = elapsed + " s";
        drawTrajectory();
    }

    waypoints.forEach(w=>{
        if(w[0]===newPos[0] && w[1]===newPos[1]){
            newCell.classList.remove("waypoint"); newCell.classList.add("visited"); newCell.innerHTML="ü§ñ";
            if(!visitedWaypoints.some(vw=>vw[0]===w[0] && vw[1]===w[1])) visitedWaypoints.push([w[0],w[1]]);
        }
    });
}

// ---------------- Manual & Debug ----------------
async function manualMove(dir){
    if(!debugMode) return;
    let prevPos = [...robotPos];
    let resp = await fetch("/step",{
        method:"POST",
        headers:{"Content-Type":"application/json"},
        body:JSON.stringify({action_name:dir})
    });
    let data=await resp.json();
    if(!data.error){
        robotPos = data.state;
        visitedWaypoints = data.visited_waypoints || [];
        updateRobot(prevPos, robotPos);
    }
}

function toggleDebug(){
    debugMode = !debugMode;
    document.getElementById("manualControls").style.display = debugMode?"block":"none";
}

// ---------------- Auto Move ----------------

// H√†m move nh∆∞ tr∆∞·ªõc (di chuy·ªÉn robot 1 b∆∞·ªõc)
function move(dx, dy) {
    let newX = robotPos[0] + dx;
    let newY = robotPos[1] + dy;
    if (newX >= 0 && newX < gridSizeX && newY >= 0 && newY < gridSizeY) {
        // check obstacle
        if (!obstacles.some(o => o[0] === newX && o[1] === newY)) {
            let prevPos = [...robotPos];
            robotPos = [newX, newY];
            trajectoryPoints.push([...robotPos]);
            updateRobot(prevPos, robotPos);
        }
    }
}

// Auto step theo random
function autoStepRandom() {
    const actions = [
        [0, 1],   // xu·ªëng
        [0, -1],  // l√™n
        [1, 0],   // ph·∫£i
        [-1, 0],  // tr√°i
    ];
    let action = actions[Math.floor(Math.random() * actions.length)];
    move(action[0], action[1]);
}

// Auto step theo greedy (tham lam ‚Üí ch·ªçn g·∫ßn goal nh·∫•t)
function autoStepGreedy() {
    const actions = [
        [0, 1],
        [0, -1],
        [1, 0],
        [-1, 0],
    ];
    let bestAction = null;
    let bestDist = Infinity;

    for (let [dx, dy] of actions) {
        let newX = robotPos[0] + dx;
        let newY = robotPos[1] + dy;

        if (newX >= 0 && newX < gridSizeX && newY >= 0 && newY < gridSizeY) {
            if (!obstacles.some(o => o[0] === newX && o[1] === newY)) {
                let dist = Math.abs(goal[0] - newX) + Math.abs(goal[1] - newY);
                if (dist < bestDist) {
                    bestDist = dist;
                    bestAction = [dx, dy];
                }
            }
        }
    }

    if (bestAction) move(bestAction[0], bestAction[1]);
}

// Ch·ªçn mode auto: "random" ho·∫∑c "greedy"
let autoMode = "random"; // m·∫∑c ƒë·ªãnh random

function startAutoMove(mode = "random") {
    if (autoMoving) return;
    autoMoving = true; algoMoving = false;
    autoMode = mode;
    startTime = performance.now();
    trajectoryPoints = [[...robotPos]];
    intervalId = setInterval(() => {
        if (autoMode === "random") autoStepRandom();
        else if (autoMode === "greedy") autoStepGreedy();
    }, 300);
    document.getElementById("msg").innerText = "Auto move (" + autoMode + ") b·∫Øt ƒë·∫ßu";
}

function stopAll() {
    autoMoving = false; algoMoving = false; currentAlgo = null;
    if (intervalId) clearInterval(intervalId);
    intervalId = null;
    document.getElementById("msg").innerText = "ƒê√£ d·ª´ng robot";
    document.getElementById("algoResult").style.display = "none";
}

// ---------------- Reset ----------------
async function resetGrid(){
    stopAll();
    let resp = await fetch("/reset",{method:"POST",headers:{"Content-Type":"application/json"},body:"{}"});
    let data = await resp.json();
    robotPos=data.state; goal=data.map.goal; obstacles=data.map.obstacles; waypoints=data.map.waypoints||[];
    visitedWaypoints=[]; gridSizeX=data.map.width; gridSizeY=data.map.height;
    drawGridOnce(); updateRobot([0,0], robotPos);
    document.getElementById("msg").innerText="M√¥i tr∆∞·ªùng ƒë√£ ƒë∆∞·ª£c reset";
    document.getElementById("current-time").innerText="-";
    trajectoryPoints=[]; clearTrajectory();
}

// ---------------- Reset All ----------------
async function resetAllGrid(){
    stopAll();
    let resp = await fetch("/reset_all", {method:"POST"});
    let data = await resp.json();
    robotPos=data.state; goal=data.map.goal; obstacles=data.map.obstacles; waypoints=data.map.waypoints||[];
    visitedWaypoints=[]; gridSizeX=data.map.width; gridSizeY=data.map.height;
    drawGridOnce(); updateRobot([0,0], robotPos);

    // Reset bi·ªÉu ƒë·ªì & stats
    allAlgoData = {};
    rewardChart.data.labels = [];
    rewardChart.data.datasets = [];
    rewardChart.update();

    clearTrajectory();
    document.getElementById("msg").innerText="üåç Gridworld ƒë√£ ƒë∆∞·ª£c reset to√†n b·ªô";
    document.getElementById("current-algorithm").innerText="-";
    document.getElementById("current-reward").innerText="-";
    document.getElementById("current-steps").innerText="-";
    document.getElementById("current-waypoints").innerText="-";
    document.getElementById("current-time").innerText="-";
}

// ---------------- Run RL Algorithms step-by-step ----------------
async function runAlgorithm(algo){
    stopAll();
    currentAlgo = algo;
    allAlgoData[algo] = { rewards: [], color: randomColor() };
    let totalReward = 0;
    let steps = 0;
    
    const resultDiv = document.getElementById("algoResult");
    resultDiv.style.display = "block";
    resultDiv.innerHTML = `<div class="loading"></div> ƒêang ch·∫°y thu·∫≠t to√°n ${algo}...`;

    // Reset tr·∫°ng th√°i tr∆∞·ªõc khi ch·∫°y
    await resetGrid();
    
    // B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p t·ª´ng b∆∞·ªõc
    intervalId = setInterval(async () => {
        try {
            let prevPos = [...robotPos];
            const resp = await fetch("/step_algorithm", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ algorithm: algo })
            });
            const data = await resp.json();

            if (data.error) {
                resultDiv.innerHTML = `‚ùå L·ªói: ${data.error}`;
                stopAll();
                return;
            }

            robotPos = data.state;
            visitedWaypoints = data.visited_waypoints || [];
            updateRobot(prevPos, robotPos);
            
            totalReward += data.reward;
            steps = data.steps;
            allAlgoData[algo].rewards.push(totalReward);
            
            updateStats(
                algo,
                totalReward.toFixed(1),
                steps,
                `${visitedWaypoints.length}/${waypoints.length}`
            );

            if (data.done) {
                resultDiv.innerHTML = `
                    ‚úÖ <strong>${algo}</strong><br>
                    üéØ Reward: ${totalReward.toFixed(1)}<br>
                    üë£ Steps: ${steps}<br>
                    üìç Waypoints: ${visitedWaypoints.length}/${waypoints.length}<br>
                    üèÜ <strong>Robot ƒë√£ ƒë·∫øn ƒë√≠ch!</strong>
                `;
                stopAll();
            } else {
                resultDiv.innerHTML = `<div class="loading"></div> ƒêang ch·∫°y thu·∫≠t to√°n ${algo}...`;
            }

            updateChart();
        } catch (e) {
            console.error(e);
            resultDiv.innerHTML = "‚ùå C√≥ l·ªói x·∫£y ra khi ch·∫°y thu·∫≠t to√°n";
            stopAll();
        }
    }, 200); // T·ªëc ƒë·ªô di chuy·ªÉn: 200ms m·ªói b∆∞·ªõc
}

// ---------------- Run A* (unchanged, v·∫´n ho·∫°t ƒë·ªông t·ªët) ----------------
async function runAStar(){
    stopAll(); currentAlgo="A*";
    const resultDiv = document.getElementById("algoResult");
    resultDiv.style.display = "block";
    resultDiv.innerHTML = `<div class="loading"></div> ƒêang ch·∫°y thu·∫≠t to√°n A*...`;

    try{
        let prevPos = [...robotPos];
        const resp = await fetch("/run_a_star",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({})});
        const data = await resp.json();
        if(data.error){ resultDiv.innerHTML = `‚ùå L·ªói: ${data.error}`; return; }
        
        allAlgoData[data.algorithm] = { rewards: data.rewards_over_time, color: randomColor() };

        let path = data.path;
        for(let i=1;i<path.length;i++){
            await new Promise(r=>setTimeout(r,200));
            prevPos = [...robotPos];
            robotPos = path[i];
            visitedWaypoints = data.visited_waypoints||[];
            updateRobot(prevPos, robotPos);
        }

        updateStats(
            data.algorithm,
            data.reward.toFixed(1),
            data.steps,
            `${data.visited_waypoints.length}/${waypoints.length}`
        );

        resultDiv.innerHTML = `
            ‚úÖ <strong>${data.algorithm}</strong><br>
            üéØ Reward: ${data.reward.toFixed(1)}<br>
            üë£ Steps: ${data.steps}<br>
            üìç Waypoints: ${data.visited_waypoints.length}/${waypoints.length}<br>
            ${data.done ? "üèÜ <strong>Robot ƒë√£ ƒë·∫øn ƒë√≠ch!</strong>" : ""}
        `;

        updateChart();
    } catch(e){
        console.error(e); 
        resultDiv.innerHTML = "‚ùå C√≥ l·ªói x·∫£y ra khi ch·∫°y A*";
    }
}

// ---------------- Draw & Clear Trajectory ----------------
function drawTrajectory(){
    let canvas=document.getElementById("trajectory");
    let ctx=canvas.getContext("2d");
    clearTrajectory();
    if(trajectoryPoints.length<2) return;
    ctx.beginPath();
    let scaleX=canvas.width/gridSizeX, scaleY=canvas.height/gridSizeY;
    ctx.moveTo(trajectoryPoints[0][0]*scaleX+scaleX/2, trajectoryPoints[0][1]*scaleY+scaleY/2);
    for(let i=1;i<trajectoryPoints.length;i++){
        ctx.lineTo(trajectoryPoints[i][0]*scaleX+scaleX/2, trajectoryPoints[i][1]*scaleY+scaleY/2);
    }
    ctx.strokeStyle="red"; ctx.lineWidth=2; ctx.stroke();
}

function clearTrajectory(){
    let canvas=document.getElementById("trajectory");
    let ctx=canvas.getContext("2d");
    ctx.clearRect(0,0,canvas.width,canvas.height);
}

// ---------------- Update Stats ----------------
function updateStats(algo, reward, steps, wp){
    document.getElementById("current-algorithm").innerText = algo;
    document.getElementById("current-reward").innerText = reward;
    document.getElementById("current-steps").innerText = steps;
    document.getElementById("current-waypoints").innerText = wp;
}

// ---------------- Kh·ªüi t·∫°o ----------------
resetGrid();
</script>

</body>
</html>
